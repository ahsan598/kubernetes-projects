# Kubernetes RBAC â€“ Dev Namespace Admin (Certificate-Based User)

### â˜¸ï¸ Overview
This project demonstrates how to create a **certificate-based Kubernetes user**
with **full administrative access restricted to a single namespace (`dev`)**.

The goal of this project is to clearly separate:
- **Authentication** (who the user is)
- **Authorization** (what the user is allowed to do)

This setup follows **real-world Kubernetes RBAC and least-privilege best practices**
commonly used in production clusters.

---

### ğŸ¯ Purpose & Context
By default, local Kubernetes clusters (KIND, Minikube, Docker Desktop) provide
an **admin kubeconfig**, which allows unrestricted access to the entire cluster,
including critical system namespaces like `kube-system`.

While this is convenient for learning, it is **not secure or realistic**.


### Why not just apply RBAC to the existing user?
RBAC in Kubernetes **does not create users**.
It only defines permissions **for an already authenticated identity**.

If we continue using the default admin identity:
- RBAC rules become meaningless
- The user can still modify any namespace
- Accidental or Destructive actions are possible

To properly enforce RBAC, Kubernetes must first **know who the user is**.

This is why we introduce a **certificate-based user**.


### ğŸ’¡ What is CSR?
**CSR (Certificate Signing Request)** is a request sent to the Kubernetes API
to obtain a **signed client certificate** that proves a user's identity.

In this project:

- A private key (`dev.key`) is generated by the user
- A CSR (`dev.csr`) is created with identity `CN=dev-user`
- The CSR is submitted to the Kubernetes API
- After approval, Kubernetes signs the request using its Certificate Authority (CA)
- The signed certificate (`dev.crt`) is issued to the user

This certificate is then used by `kubectl` to **authenticate** as `dev-user`.

> - Kubernetes identifies users using the **Common Name (CN)** field of the certificate.
> - This value must exactly match the user name referenced in RBAC bindings.


### ğŸ“œ Why Certificates Are Needed
Certificates establish **identity**, not permissions.

- CSR + Certificate â†’ *Authentication* (Who are you?)
- RBAC (Role / RoleBinding) â†’ *Authorization* (What can you do?)

Without a valid identity:
- RBAC rules cannot be enforced
- Kubernetes cannot distinguish one user from another


---

### ğŸ“ Why This Project?
- Understand **Kubernetes authentication** using `x509` certificates
- Implement **RBAC with least privilege**
- Prevent accidental changes to **system namespaces**
- Practice **production-like Kubernetes security patterns**


### âš™ï¸ Components
- **Namespace**: `dev`
- **User**: `dev-user` (`x509` certificate-based)
- **Role**: `dev-admin-role` (full access within `dev`)
- **RoleBinding**: Binds `dev-user` to the role
- **Context**: `dev-context`


### ğŸ” Access Flow
```txt
User â†’ Certificate â†’ Role â†’ RoleBinding â†’ Context â†’ Namespace
```

### ğŸ“‚ Project Structure
```txt
k8s-rbac-dev-project/
â”œâ”€â”€ certs/                     # Certificate-based authentication (DO NOT COMMIT)
â”‚   â”œâ”€â”€ dev.key                # Private key for dev-user
â”‚   â”œâ”€â”€ dev.csr                # Certificate Signing Request submitted to Kubernetes
â”‚   â””â”€â”€ dev.crt                # Signed client certificate issued by Kubernetes CA
â”œâ”€â”€ rbac/                      # RBAC authorization definitions
â”‚   â”œâ”€â”€ role-dev-admin.yaml    # Namespace-scoped admin Role for dev namespace
â”‚   â””â”€â”€ rolebinding-dev-admin.yaml # Binds dev-user to dev-admin-role
â”œâ”€â”€ dev-user-csr.yaml          # Kubernetes CSR resource for dev-user authentication
â”œâ”€â”€ namespace.yaml             # Creates and scopes the dev namespace
â”œâ”€â”€ .gitignore                 # Excludes sensitive certs and local artifacts
â””â”€â”€ readme.md                  # Project documentation explaining auth, RBAC, and flow
```

### ğŸš€ Setup & Deployment Steps

**1. Create Namespace:**
Create the `dev` namespace using the provided manifest:
```sh
kubectl apply -f namespace.yaml
```

**2. Generate Certificates for `dev-user`**
```sh
# Generate private key for dev-user
openssl genrsa -out dev.key 2048

# Create CSR (CN = username in Kubernetes)
openssl req -new -key dev.key -out dev.csr -subj "/CN=dev-user"

# Base64 encode CSR
base64 -w 0 dev.csr
```

**3. Create Kubernetes CSR Object:**
Create the CSR resource using the provided YAML file:
```sh
kubectl apply -f dev-user-csr.yaml
```
> **Note:**  
> - `dev-user-csr.yaml` is a Kubernetes CSR resource that submits the
> base64-encoded certificate request to the Kubernetes API.
> - Approval of this resource is required before the certificate can be issued.


**4. Approve CSR & Extract Client Certificate**
```sh
# Approve the CSR
kubectl certificate approve dev-user

# Check certificate expiry
openssl x509 -in dev.crt -noout -dates

# Extract signed certificate
kubectl get csr dev-user \
  -o jsonpath='{.status.certificate}' | base64 --decode > dev.crt
```

**5. Create Role & RoleBinding:**
Apply RBAC manifests to grant full admin access only within the `dev` namespace:
```sh
kubectl apply -f rbac/role-dev-admin.yaml
kubectl apply -f rbac/rolebinding-dev-admin.yaml
```

**6. Configure kubeconfig Context**
```sh
# Register dev-user credentials
kubectl config set-credentials dev-user \
  --client-certificate=dev.crt \
  --client-key=dev.key

# Create a context scoped to dev namespace
kubectl config set-context dev-context \
  --cluster=kind-dev-cluster \
  --user=dev-user \
  --namespace=dev

# Switch to dev context
kubectl config use-context dev-context
```
![user-context](./assets/images/user-context.png)


**7. Verification**
```sh
kubectl auth can-i create pods -n dev
# yes

kubectl auth can-i delete deployments -n dev
# yes

kubectl auth can-i get pods -n kube-system
# no
```
![verification](./assets/images/context-verify.png)


### ğŸ” User Lifecycle Operations

**1. Remove User Access (Authorization Only)**

To remove `dev-user` access completely remove **RoleBinding**
```sh
kubectl delete rolebinding dev-admin-binding -n dev

# Verify
kubectl auth can-i get pods -n dev
# no âŒ
```
Identity still exists, but no permissions.


**2. Rotate User Certificate (Authentication)**
When to rotate?
- Before certificate expire
- Compromised key
- Periodic security rotation

Follow below steps to rotate certificate
```sh
# create new key & csr
openssl genrsa -out dev-new.key 2048
openssl req -new -key dev-new.key -out dev-new.csr -subj "/CN=dev-user"

# create new CSR object
# approve
# extract new dev.crt
```
Update kubeconfig:
```sh
kubectl config set-credentials dev-user \
  --client-certificate=dev-new.crt \
  --client-key=dev-new.key
```
RBAC unchanged


**3. Temporarily Disable User**

Option-A: CSR revoke (simple)
```sh
kubectl delete csr dev-user
```
Option B: RoleBinding remove (best)
```sh
kubectl delete rolebinding dev-admin-binding -n dev
```
ğŸ“Œ RBAC removal safest & fastest.


**4. Permanently Remove User**

Kubernetes does not store users as API resources.
A "user" is an external identity represented by:
- Certificates
- RBAC bindings
- kubeconfig entries

To permanently remove a user, all references to the identity must be removed.

**a. Remove Authorization (RBAC)**
```sh
kubectl delete rolebinding dev-admin-binding -n dev
```
**b. Invalidate Authentication**
- Do not renew or reissue the certificate
- Allow the certificate to expire naturally
- Remove the certificate files if stored (`dev.crt`)

> **Note:** Kubernetes does not support active revocation of issued client certificates.
> - To reduce risk, always issue **short-lived certificates** by explicitly setting
> - `expirationSeconds` (for example, `86400` for 1 day).


**c. Clean up kubeconfig**
```sh
kubectl config delete-context dev-context
kubectl config delete-user dev-user
```

---

### ğŸ” Security Notes
- User has no access to `kube-system`
- Permissions are namespace-scoped
- `ClusterRole` is intentionally avoided
- Follows least-privilege and blast-radius reduction principles


### ğŸ“š Use Cases
- Multi-tenant clusters
- Developer-only namespace access
- Safe local / lab Kubernetes environments
- RBAC demonstration for learning & practice


### ğŸ“ Key Takeaways
- RBAC does not create users â€” it only authorizes identities 
- CSR and certificates provide that identity 
- while RBAC controls the scope of access

This project demonstrates how both work together to create
a **secure, production-like Kubernetes access model**.